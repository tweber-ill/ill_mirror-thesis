%
% tests
% @author Tobias Weber <tweber@ill.fr>
% @date aug-2021
% @license see 'LICENSE' file
%

\chapter{Test Tools and Unit Tests}
\label{ch:tests}
Due to a rapid increase in its complexity over time, the software of this work 
necessitated a multi-tiered testing strategy during development, including test programs and unit tests.
Even after having finished the critical phases of development, the programs which are 
presented in this chapter serve to ensure that the software and its parts continue to work as intended. 
Problems that may arise can be rapidly analysed using the simplified environments these tools provide.

Before having being integrated into the main library or the GUI program, each essential function was tested 
separately. This was done either via small test programs or via dedicated unit tests, which are discussed in 
section \ref{sec:unit_tests}.
Integration tests of algorithms, where collections of functions are tested how and if they work together, 
were performed using larger bespoke test tools, which implemented a simplified versions of the functionality 
of the main programs. These are described in section \ref{sec:tests_tools}.


\section{Test tools}
\label{sec:tests_tools}
First, we describe the collection of tools that served in testing aspects of the main path-finding algorithm.

\subsection{Line segments tool}
\label{sec:tests_linesegs}

The line segment tool (Fig. \ref{fig:linesgui}), whose source code can be found in the file \lstinline|./src/tools/lines.cpp|, 
performs several kinds of computations to test the line-based algorithms that are used in the core module.

The most important of these is the calculation of line segment Voronoi diagram bisectors as shown in 
Fig. \ref{fig:linesgui} (a), please also refer to chapter \ref{sec:voro_ls}.
To that end, it uses two different backend libraries between which the user can switch dynamically in
the program. These libraries are \textit{Boost.Polygon}'s Voronoi module \cite{web_boost_polygon_voronoi} for one
and \textit{OpenVoronoi} \cite{web_openvoronoi} for the other.
The correctness of the calculation is furthermore checked by iterating the points of the $\mathbb{R}^2$ plane
on a grid and testing to which line segment they are closest. These are the coloured regions in Fig. \ref{fig:linesgui} (a).
The line segment tool can load the regions of the angular configuration space that are calculated in the main
program (chapter \ref{sec:line_seg_generation}), and was used for debugging purposes in its development and
for testing different approaches to the algorithms used in the main program.

Another calculation the line segment tool performs and which is shown in Fig. \ref{fig:linesgui} (b), is the 
calculation of trapezoidal maps (chapter \ref{sec:pointrobot_sector}), which are calculated according to the 
algorithm given in Ref. \cite[Ch. 6, pp. 121-146]{Berg2008}.
The purpose of this was for early testing which sector-based method would be most suitable
for path-mesh building. The trapezoid maps were deemed infeasible and were ruled out after
these tests.

The third calculation that was tested in this tool is the sweep-based intersection of line segments which
is used in the main algorithm for intersections checks between polygons, as has been discussed in 
chapter \ref{sec:angular_config_space}.
The implementation is based on the algorithm given in Ref. \cite[pp. 69-80]{FUH_geo2020}.

\begin{figure}[htb]
	\centering
	\includegraphics[width = 0.49 \textwidth]{figures/linesgui_voro}
	\hspace{0.05cm}
	\includegraphics[width = 0.49 \textwidth]{figures/linesgui_trapezoid}

	\vspace{0.25cm}
	\includegraphics[width = 0.49 \textwidth]{figures/linesgui_inters}
	\caption[Line segments tool.]{Line segments tool.
		This program allows the dynamic calculation of
		(a) line segment Voronoi regions (coloured) and bisectors (black lines),
		(b) trapezoidal maps, and
		(c) sweep-based points of intersection (green points).
		Line segment vertices can be inserted, deleted and moved using the mouse.
		\label{fig:linesgui}}
\end{figure}



\subsection{Polygon tool}
\begin{figure}[htb]
	\centering
	\includegraphics[width = 0.49 \textwidth]{figures/polygui_convex}
	\hspace{0.05cm}
	\includegraphics[width = 0.49 \textwidth]{figures/polygui_kernel}
	\caption[Polygon tool.]{Polygon tool.
		This program calculates the
		(a) convex sub-regions of a concave polygon, and
		(b) the visibility kernel (red) of a polygonal region.
		Polygon vertices can be inserted, deleted and moved using the mouse, updates
		are performed dynamically.
		\label{fig:linesgui}}
\end{figure}



\subsection{Convex hull tool}
\label{sec:tests_hull}
\begin{figure}[htb]
	\centering
	\includegraphics[width = 0.49 \textwidth]{figures/hullgui_voro}
	\hspace{0.05cm}
	\includegraphics[width = 0.49 \textwidth]{figures/hullgui_kruskal}
	\caption[Convex hull tool.]{Convex hull tool.
		This program calculates 
		(a) the convex hull (thick black lines), the Voronoi diagram (red lines), 
			the Delaunay triangulation (thin black lines), as well as
		(b) Kruskal's minimum spanning tree (green lines)
		of a collection of vertices.
		As with the other test tools, the vertices can be inserted, deleted and moved 
		using the mouse, updates are performed dynamically.
		\label{fig:linesgui}}
\end{figure}




\section{Unit tests}
\label{sec:unit_tests}
A unit test tests if a given set of inputs to a function gives an expected set of outputs.
Testing an algorithm containing several function calls also allows to check if a set of invariants
is fulfilled during the algorithm run, meaning between function calls.
Possible checks can either be fixed input values which are testes agains known output values,
or random inputs for which the correct output is calculated independently using a different 
method than the one being tested, or even an external program.
Unit tests allow to spot an error for which they are specifically designed. Conversely, they cannot 
prove that a software is free of errors. Such a feat would be the task of software verification, 
which is very complicated, if not impossible for software systems of a certain size and complexity.

For the present software, unit tests of isolated functions and algorithms were performed using the 
C++ library \textit{Boost.Test} \cite{web_boost_test}.
In \textit{Boost.Test}, test modules are defined per unit test file, which contains one or more test cases.
These test cases can also be configured to create different instances of template functions using
different template arguments. The body of a test case contains a block of normal C++ code.
In the C++ code, conditions and invariants are tested using the 
\lstinline[language=C++]|BOOST_TEST()| macro. Each successful or non-successful evaluation
of the macro is registered by \textit{Boost.Test} and reported in a final summary.
