%
% path-finding user interfaces
% @author Tobias Weber <tweber@ill.fr>
% @date july-2021
% @license see 'LICENSE' file
%

\chapter{User Interfaces}
\label{ch:gui}

The software of the present work has been realised in a modular fashion, it comprises a core
module (see chapter \ref{ch:impl}), which can be easily used as a library and linked into 
external C++ applications. More details on the core library can be found in section \ref{sec:library}.
Such a library usage will be important in the future when we plan to utilise the software as a 
plug-in module to the instrument control software \textit{NOMAD} \cite{web_NOMAD} that is 
employed at the Institut Laue-Langevin.

Furthermore, a graphical user interface (GUI) has been implemented for a visual and interactive 
representation of the instrument and the underlying algorithms. 
The GUI is described in detail in section \ref{sec:gui}.

Finally, the software allows scripting via \textit{Python} \cite{Rossum2011, web_python}. 
Apart from simply setting up a workflow and plotting the results, the \textit{Python} interface 
will allow the usage of the software in \textit{Python}-based instrument control systems such as 
\textit{NICOS} \cite{web_NICOS}, which is used at the Forschungsreaktor M\"unchen II (FRM-II). 
Details on the scripting interface can be found in section \ref{sec:scripting}.



\section{Core module and C++ library}
\label{sec:library}
The core module comprises all necessary calculation as well as input and output sub-modules. 
Here, we only describe the latter two, since the computation functionality of the core module 
has already been treated in chapter \ref{ch:impl}.

The instrument configuration is read from an \textit{XML} file whose hierarchical structure
mirrors the internal data organisation of the core module and its class hierarchy.
The \textit{XML} file is parsed using the \textit{Boost.PropertyTree} library \cite{web_boost_proptree}
and objects are created of the respective classes once the corresponding section in the \textit{XML}
structure is discovered. An \textit{XML} section is handed down to the corresponding \textit{C++} object,
so that each object only receives the portions of the \textit{XML} configuration it is responsible for.
Editing the \textit{XML} instrument configurations can be done using the GUI module of section \ref{sec:gui}.

While the central \lstinline[language=C++]|PathBuilder| class offers getter functions for all intermediate
data that is generated during each step of the calculation workflow, the final results are output using
the classes derived from the purely virtual class \lstinline[language=C++]|PathsExporterBase| that resides
in the files \lstinline|./src/core/PathsExporter[.h,.cpp]|. Currently, three possible output classes
are available:
\begin{itemize}
	\item \lstinline[language=C++]|PathsExporterRaw|, which outputs the vertices of the calculated 
		final instrument path in a raw text format.
	\item \lstinline[language=C++]|PathsExporterNomad|, which writes out commands for driving the
		motors of instruments which are controlled by the \textit{NOMAD} software \cite{web_NOMAD}.
	\item \lstinline[language=C++]|PathsExporterNicos|, which generates \textit{Python} code to
		be used for driving the instrument using the \textit{NICOS} \cite{web_NICOS} control system.
\end{itemize}
For easy extensibility and to isolate the \lstinline[language=C++]|PathBuilder| class from the output
code, the output class hierarchy is realised using the Visitor pattern \cite{wiki_visitor}, where
the \lstinline[language=C++]|PathBuilder| accepts the output base class and dispatches to the
desired child object.

The core module functionality is self-contained and does, for instance, not depend on any GUI code.
It is therefore straightforward to statically or dynamically link it to external applications which 
wish to use the path-finding functionality. To avoid exposing the user to the complexities of 
the \textit{C++} language, a more comfortable approach is provided by both the graphical as well 
as the \textit{Python} interface, which are described in the following sections.



\section{Graphical user interface}
\label{sec:gui}
The software's main graphical user interface (GUI), for which a typical session is depicted
in Fig. \ref{fig:gui}, is based on the \textit{Qt} framework \cite{web_Qt}, that allows
for an easy and rapid cross-platform GUI development in \textit{C++}. We support both
current releases of \textit{Qt}, namely version 5 and version 6.
Similar to the core calculation module, the GUI is written in the recent \textit{C++20}
standard \cite{ISOCPP20} of the C++ language family \cite{Stroustrup2008, Stroustrup2018}.
The source code of the GUI module can be found in the directory \lstinline|./src/gui| of the
source repository, see chapter \ref{ch:online} for more information.

\begin{figure}[htb]
		\begin{center}
			\includegraphics[width = 1 \textwidth]{figures/gui}
		\end{center}
	\caption[Main program GUI.]{Main GUI. Here, instrument and sample crystal properties can be set up,
		walls can be added and moved and paths around them be calculated.
		The central view provides a three-dimensional visualisation of the instrument
		configuration and is fully dynamic: Every element, including the instrument
		and the wall segments, can be moved or manipulated using the mouse.
		See the text for a description of each interface element.
		\label{fig:gui}}
\end{figure}

The functions of the individual control elements of the main GUI, which are marked as (a)-(f)
is explained in the following sections. Each of the panels corresponds to a specific
functionality. Hereby, all calculation is performed in the core module, which is described in
chapter \ref{ch:impl} and to which the GUI is just that, an interface.
By the same token, the core module itself is completely independent of the GUI, or any other
interface code, and the full functionality of the software, except GUI-specific visualisations,
is equally accessible from the other alternative interface modules, e.g. the \textit{Python}
interface described in section \ref{sec:scripting}, or the raw \textit{C++} library interface.



\subsection{Crystal definition dock window}
\label{sec:gui_xtal}
\begin{minipage}{1 \textwidth}
\setlength{\intextsep}{0.25cm}
\begin{wrapfigure}{r}{0.46 \textwidth}
	\vspace{-0.25cm}
	\includegraphics[width = 0.45 \textwidth]{figures/gui_xtal}
	\caption[Crystal definition window]{Crystal definition window (a).
		\label{fig:gui_xtal}}
\end{wrapfigure}

Dock window (a) of the main GUI (Fig. \ref{fig:gui}) sets up the crystal $UB$ matrix
from a sample definition according to the formalism described in chapter \ref{ch:xtal}.
The window is magnified in Fig. \ref{fig:gui_xtal}. As seen before, this matrix transforms
the crystal coordinate system into the instrument's laboratory coordinate system.
The necessary information for the $B$ matrix comprise the axis lengths of the sample lattice's
unit cell as well as the axis angles for the non-Cartesian crystal coordinate system.
The $UB$ matrix rotates the crystal coordinate system so that the $x$ and $y$ axes correspond
to the 2-d scattering plane accessible by the instrument, see chapter \ref{ch:xtal}
for more information.
Finally, the $B$ and $UB$ matrices for the entered crystal information are shown in the
floating window right of (a).
\end{minipage}
\vspace{0.5cm}



\subsection{Instrument properties dock window}
\begin{minipage}{1 \textwidth}
\setlength{\intextsep}{0.25cm}
\begin{wrapfigure}{l}{0.3 \textwidth}
	\vspace{-0.25cm}
	\includegraphics[width = 0.25 \textwidth]{figures/gui_instrument}
	\caption[Instrument properties window]{Instrument properties window (b).
		\label{fig:gui_instr}}
\end{wrapfigure}

The raw instrument properties, which are agnostic of any sample crystal coordinates, are set 
using the dock window shown in Fig. \ref{fig:gui_instr}. It displays and lets the user modify
any crystal rotation angles, both the rocking angles of the crystals around their own axes
as well as the scattering angle with respect to the following axis. These angles and their
use in diffraction (two-axis) and spectroscopy (three-axis) instruments is described in chapters
\ref{ch:intro} and \ref{ch:xtal}. 
The fields names ``$d$ spacings'' correspond to the spacing of the crystal planes in the 
monochromator and analyser crystals. In our examples we use the value of $d=3.355 \AA{}$
which corresponds to scattering on the $\left(002\right)$ Bragg reflection of highly oriented
pyrolithic graphite (HOPG) \cite{TODO}, which is one of the standard crystals used in a monochromator
at a TAS instrument.
Finally, the check boxes named ``scattering senses'' control the sign of the scattering angles.
If the box is checked, a positive angle corresponds to a mathematically positive sense 
(counterclockwise), or to a negative sense (clockwise) when unchecked.
From the standpoint of the physics to be studied in the sample, these signs have no influence
in practice. They do, however, strongly affect the resolution of the instrument \cite{TODO}
and have to be considered carefully in the set-up of an experiment.
\end{minipage}



\subsection{Main workspace}
The largest portion of the screen is reserved for the workspace.
A typical view is shown in element (c) of Fig. \ref{fig:gui}.
Here, a graphical representation of the instrument and the walls as well as the interaction
with these elements is performed using \textit{OpenGL} \cite{web_OpenGL} via \textit{Qt}'s
\lstinline[language=C++]|QOpenGLWidget| \cite{web_QOpenGLWidget} class.
The current view of the instrument is controlled by moving the mouse while holding the right button.
The camera position, viewing angle and direction as well as the kind of projection are displayed in dock
window (f) and can also be entered directly.
The workspace is not restricted to a passive view of the instrument, but also functions as an editor.
as it allows for an easy insertion, editing and removal of wall segments. The segments as well as the
instrument axes themselves can be dynamically moved by dragging them using the mouse.



\subsection{Crystal coordinates dock window}
\label{sec:gui_xtalcoords}
\begin{minipage}{1 \textwidth}
\setlength{\intextsep}{0.25cm}
\begin{wrapfigure}{r}{0.26 \textwidth}
	\vspace{-0.25cm}
	\includegraphics[width = 0.25 \textwidth]{figures/gui_xtalcoords}
	\caption[Crystal coordinates window]{Crystal coordinates window (d).
		\label{fig:gui_xtalcoords}}
\end{wrapfigure}

Using the $UB$ transformation matrix that has been set up before (sec. \ref{sec:gui_xtal}),
an instrument position can be entered in the crystal coordinates dock window, which is
shown in Fig. \ref{fig:gui_xtalcoords}.
At triple-axis spectrometers, coordinates are given as four-dimensional tuples of the
form $\left(h\  k\  l\  E \right)^t$, where the three-dimensional momentum transfer
vector in the coordinate system of the instrument and its relation to the initial and final
wavevectors $\underline{k}_i$ and $\underline{k}_f$, is thus \cite[p. 11]{Shirane2002} \cite{Lumsden2005}
\begin{equation}
	\underline{Q}\ =\ UB\cdot \left(\begin{array}{c} h \\ k \\ l \end{array}\right) \ \equiv\ \underline{k}_i - \underline{k}_f.
\end{equation}
The fourth coordinate component, namely the energy transferred to the crystal, is \cite[p. 11]{Shirane2002}
\begin{equation}
	E \ =\ \frac{\left( \hbar k_i \right)^2}{2 m_n} - \frac{\left( \hbar k_f \right)^2}{2 m_n}.
\end{equation}
The checkbox labelled ``keep $k_f$ = const'' selects which one of the two wavenumbers, $k_i$ or $k_f$,
is kept constant to effectuate the energy transfer.
Please refer to chapters \ref{ch:intro} and \ref{ch:xtal} for details on the calculations and physics.

The button labelled ``jump to coordinates'' sets the current (and initial path position)
of the instrument to the given crystal coordinates, whereas the ``set target angles'' button
sets the target position on the instrument path.

\end{minipage}



\subsection{Path properties dock window and dialog}
\begin{minipage}{1 \textwidth}
\setlength{\intextsep}{0.25cm}
\begin{wrapfigure}{l}{0.26 \textwidth}
	\vspace{-0.25cm}
	\includegraphics[width = 0.25 \textwidth]{figures/gui_path}
	\caption[Path properties window]{Path properties window (e).
		\label{fig:gui_path}}
\end{wrapfigure}

Finally, the calculation of the instrument path is done using the path properties dock window
given in Fig. \ref{fig:gui_path}. Here, the target scattering angles are calculated from the crystal
coordinates and set by the previous step (sec. \ref{sec:gui_xtalcoords}). For direct positioning,
the angles can also be entered manually, thereby overriding the crystal coordinate calculations.

The button labelled ``calculate path mesh'' starts the calculation of the skeletal bisectors that are
described in chapter \ref{sec:polygonal_voronoi_diagram}.
The ``calculate path'' button finds the optimal path on the mesh and invokes the core library
functions described in chapter \ref{sec:exepath}.
Once a path has been calculated, its positions can be tracked using the progress bar at the bottom
of the dock window.

Details on the path calculations, including the path mesh, are displayed in the angular configuration
space dialog that is depicted in Fig. \ref{fig:gui_configspace}.
Here, the start and target positions can also be directly dragged and dropped via mouse and the
effects on the calculation are visualised live.
The library \textit{QCustomPlot} \cite{web_QCustomPlot} is used for plotting.

\end{minipage}



\begin{figure}[htb]
		\begin{center}
			\includegraphics[width = 0.66 \textwidth]{figures/gui_configspace}
		\end{center}
	\caption[Configuration space dialog.]{Angular configuration space and path calculation.
	The figure plots all possible instrument positions for the monochromator and sample
	scattering angles, $2\theta_M$ and $2\theta_S$, respectively. Forbidden positions
	are shown in red.
	These can be invalid angles as well as collisions of the instrument with walls
	(here, specifically, the pillar from Fig \ref{fig:gui}), or with itself.
	Allowed positions are drawn in blue. The mesh of all possible instrument
	paths is shown as white lines, while a currently selected example path from
	the red start to the green target position is shown as a yellow line.
		\label{fig:gui_configspace}}
\end{figure}





\section{Python scripting interface}
\label{sec:scripting}

In order to allow for a simple inclusion of the core module (see section \ref{sec:library}) of the present 
software in other tools, a scripting interface has been developed using the interface generator \textit{SWIG} \cite{web_swig}. 
\textit{SWIG} is a tool which parses \textit{C} or \textit{C++} header files and creates a native interface 
for several possible scripting languages, of which we opted for \textit{Python} \cite{Rossum2011, web_python} 
as it has become the most popular programming language in neutron science over the last decade.
As the core module already has the structure of a library, the effort to offer scripting functionality
was minimal. Only a few helper functions had to be included in several classes, because \textit{SWIG}
is not yet fully \textit{C++20} compliant and had some problems with new language features such as 
template concepts \cite{TODO}.
The \textit{SWIG} interface definition, which maps the \textit{C++} classes to corresponding Python classes of the same name, 
can be found in the file \lstinline|./scripting/taspaths.i| of the source repository.

An example of the full workflow of loading an instrument definition file, creating a path mesh and finding
the path from a start position in crystal coordinates to a target position is given in listings \ref{lst:pyworkflow1}, \ref{lst:pyworkflow2} and \ref{lst:pyworkflow3}.
The native core module is imported into \textit{Python} as the name \lstinline[language=C++]|tas| on line 9 of the script,
instances of its classes are generated for the individual functionalities.
Specifically, the instrument space class from chapter \ref{sec:tasmodel}, which is the representation of the instrument 
and which is furthermore responsible for the local instrument axis coordinate systems, collision detection, as well as 
loading and saving of instrument configurations, is created on line 37. 
Next, the triple-axis and single-crystal calculator class from chapter \ref{ch:xtal} is created on line 51 and is 
used to set-up the instrument scattering senses and a single-crystal coordinate system.
Finally, the path builder class, which has been described in chapter \ref{sec:buildpath}, is created on line 64 
and used in the rest of the script to calculate the path mesh as
well as the concrete path between the given crystal coordinate points.
The results of the script are shown in Fig. \ref{fig:pyworkflow}, where we employ \textit{Matplotlib} \cite{web_matplotlib} 
to plot the calculated path and the obstacles in configuration space.

\begin{figure}[htb]
		\begin{center}
			\includegraphics[width = 0.66 \textwidth]{figures/pyworkflow}
		\end{center}
	\caption[Python workflow results.]{Results from the \textit{Python} workflow example of listings
		\ref{lst:pyworkflow1}, \ref{lst:pyworkflow2} and \ref{lst:pyworkflow3}, directly plotted 
		in \textit{Python} using \textit{Matplotlib} \cite{web_matplotlib}.
		The obstacles are shown as red regions, the calculated instrument path is shown as a blue curve.
		\label{fig:pyworkflow}}
\end{figure}


\begin{listing}[htb]
	\begin{lstlisting} [language = Python, 
		basicstyle = {\scriptsize},
		breaklines = true, tabsize = 4,
		numbers = left, firstnumber = 1, numberstyle={\scriptsize}]
import sys
import os
import math as m

cwd = os.getcwd()
sys.path.append(cwd)

# import native C++ core module
import taspaths as tas

# -----------------------------------------------------------------------------
# helper functions
# -----------------------------------------------------------------------------
def error(msg):
	print("Error: %s" % msg)
	exit(-1)

def warning(msg):
	print("Warning: %s" % msg)
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# options
# -----------------------------------------------------------------------------
write_pathmesh = False
write_path = False
show_plot = True
file_name = "../res/instrument.taspaths"
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# load instrument
# -----------------------------------------------------------------------------
print("Loading instrument definition...")

# create the instrument space and load an instrument definition
instrspace = tas.InstrumentSpace()
[file_ok, file_date] = tas.InstrumentSpace.load(file_name, instrspace)

if file_ok:
	print("Loaded \"%s\", dated %s." % (file_name, file_date))
else:
	error("Could not load \"%s\"." % (file_name))

print("Instrument definition loaded.\n")
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# set-up a sample single-crystal
# -----------------------------------------------------------------------------
tascalc = tas.TasCalculator()
tascalc.SetScatteringSenses(True, False, True)
tascalc.SetSampleLatticeConstants(5, 5, 5)
tascalc.SetSampleLatticeAngles(90, 90, 90, True)
tascalc.UpdateB()
tascalc.UpdateUB()
# -----------------------------------------------------------------------------
	\end{lstlisting}
	\caption[Python workflow example 1/3.]{Script showing an example workflow in \textit{Python}.
	Part 1 of 3: Set-up of the instrument and the sample crystal.
	\label{lst:pyworkflow1}}
\end{listing}



\begin{listing}[htb]
	\begin{lstlisting} [language = Python, 
		basicstyle = {\scriptsize},
		breaklines = true, tabsize = 4,
		numbers = left, firstnumber = 58, numberstyle={\scriptsize}]
# -----------------------------------------------------------------------------
# build path mesh
# -----------------------------------------------------------------------------
print("Building path mesh...")

# create the paths builder object
builder = tas.PathsBuilder()
builder.AddConsoleProgressHandler()
builder.SetInstrumentSpace(instrspace)
builder.SetTasCalculator(tascalc)
print("Path builder uses %d threads." % builder.GetMaxNumThreads())

# angular ranges to probe
angle_padding = 4.
a2_delta = 1./180.*m.pi
a4_delta = 2./180.*m.pi
a2_begin = 0. - angle_padding*a2_delta
a2_end = m.pi + angle_padding*a2_delta
a4_begin = -m.pi - angle_padding*a4_delta
a4_end = m.pi + angle_padding*a4_delta

if not builder.CalculateConfigSpace(
	a2_delta, a4_delta,
	a2_begin, a2_end,
	a4_begin, a4_end):
	error("Angular configuration space could not be calculated.")

if not builder.CalculateWallContours(True, False):
	error("Obstacle contours could not be calculated.")

if not builder.CalculateLineSegments():
	error("Line segments could not be calculated.")

if not builder.CalculateVoronoi(False):
	error("Voronoi diagram could not be calculated.")

print("Finished building path mesh.\n")
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# set-up the start and target coordinates of a path
# -----------------------------------------------------------------------------
print("Calculating path...")

tascalc.SetKf(1.4)
start_angles = tascalc.GetAngles(0.5, 0., 0., 1.)
target_angles = tascalc.GetAngles(1.5, -0.5, 0., 2.5)

# take absolute angles
start_angles.monoXtalAngle = abs(start_angles.monoXtalAngle)
start_angles.sampleXtalAngle = abs(start_angles.sampleXtalAngle)
start_angles.sampleScatteringAngle = abs(start_angles.sampleScatteringAngle)
target_angles.monoXtalAngle = abs(target_angles.monoXtalAngle)
target_angles.sampleXtalAngle = abs(target_angles.sampleXtalAngle)
target_angles.sampleScatteringAngle = abs(target_angles.sampleScatteringAngle)

print("Start angles: a1 = %.2f deg, a5 = %.2f deg, a3 = %.2f deg, a4 = %.2f deg." % (
	start_angles.monoXtalAngle / m.pi*180.,
	start_angles.anaXtalAngle / m.pi*180.,
	start_angles.sampleXtalAngle / m.pi*180.,
	start_angles.sampleScatteringAngle / m.pi*180.))

print("Target angles: a1 = %.2f deg, a5 = %.2f deg, a3 = %.2f deg, a4 = %.2f deg." % (
	target_angles.monoXtalAngle / m.pi*180.,
	target_angles.anaXtalAngle / m.pi*180.,
	target_angles.sampleXtalAngle / m.pi*180.,
	target_angles.sampleScatteringAngle / m.pi*180.))
# -----------------------------------------------------------------------------
	\end{lstlisting}
	\caption[Python workflow example 2/3.]{Script showing an example workflow in \textit{Python}.
	Part 2 of 3: Calculation of the path mesh and the start and target positions from their crystal coordinates.
	\label{lst:pyworkflow2}}
\end{listing}


\begin{listing}[htb]
	\begin{lstlisting} [language = Python, 
		basicstyle = {\scriptsize},
		breaklines = true, tabsize = 4,
		numbers = left, firstnumber = 126, numberstyle={\scriptsize}]
# -----------------------------------------------------------------------------
# find path
# -----------------------------------------------------------------------------
path = builder.FindPath(
		start_angles.monoXtalAngle * 2., start_angles.sampleScatteringAngle,
		target_angles.monoXtalAngle * 2., target_angles.sampleScatteringAngle)
if not path.ok:
	error("No path could be found.")

builder.SetSubdivisionLength(0.5)
vertices = builder.GetPathVerticesAsPairs(path, True, True)

print("Finished calculating path.\n")
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# output and plotting
# -----------------------------------------------------------------------------
# write the path mesh vertices to a file
if write_pathmesh:
	if not builder.SaveToLinesTool("lines.xml"):
		warning("Could not save line segment diagram.")

# write the path vertices to a file
if write_path:
	with open("path.dat", "w") as datafile:
		for vertex in vertices:
			datafile.write("%.4f %.4f\n" % (vertex[0], vertex[1]))

# plot the angular configuration space
if show_plot:
	import matplotlib.pyplot as plt

	# plot obstacles
	numgroups = builder.GetNumberOfLineSegmentRegions()
	print("Number of regions: %d." % numgroups)
	for regionidx in range(numgroups):
		region = builder.GetLineSegmentRegionAsArray(regionidx)
		x1, y1, x2, y2 = zip(*region)
		plt.fill(x1, y1, "-", linewidth = 1,
			fill = not builder.IsRegionInverted(regionidx), 
			color = "#ff0000")

	# plot path
	x, y = zip(*vertices)
	plt.xlabel("Sample Scattering Angle 2\u03b8_S (deg)")
	plt.ylabel("Monochromator Scattering Angle 2\u03b8_M (deg)")
	plt.plot(x, y, "-", linewidth=2)

	plt.show()
# -----------------------------------------------------------------------------

	\end{lstlisting}
	\caption[Python workflow example 3/3.]{Script showing an example workflow in \textit{Python}.
	Part 3 of 3: Calculation of the path between the start end target positions and plotting.
	\label{lst:pyworkflow3}}
\end{listing}


\section{Summary}
TODO
