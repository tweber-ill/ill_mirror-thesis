%
% gl
% @author Tobias Weber <tweber@ill.fr>
% @date aug-2021
% @license see 'LICENSE' file
%

\chapter{Basic Concepts, Algorithms and Data Structures}
\label{ch:algos}
The  path-finding algorithm and implementation, that will be presented in the following chapters,
employs several different concepts, data structures and methods.
In this chapter, these basic building blocks are reviewed in a general manner.


\section{Voronoi diagrams}
\label{sec:voro}
As we will see in the next chapter, a concept that will play a central role for the path-finding 
algorithm of this work is the Voronoi diagram.
A good review of Voronoi diagrams is given in Ref. \cite[Ch. 7, pp. 147-171]{Berg2008} 
and in \cite[Ch. 5, pp. 209f]{FUH_geo2020}, which we follow in this chapter.

Starting with some basic definitions, a \textit{Voronoi diagram} is a set of 
\textit{bisectors}, $B\left(\underline{x},\, \underline{y}\right)$, separating \textit{Voronoi regions}.
A Voronoi region names the set of points $\underline{x}$ in a vectorspace $V$ that are closest to 
a given site $\underline{s}$ under a given metric $\left\Vert \cdot \right\Vert$, which measures distances in $V$.
The site can either be isolated vertices, lines or any other finite object.
Formally, the bisector between two sites $\underline{s}_1$ and $\underline{s}_2$ is, 
generalising from \cite[p. 140]{Icking2001},
\begin{equation}
	B\left(\underline{s}_1,\, \underline{s}_2\right)\ =\ \left\{ \underline{x} \in V \ |\ 
		\left\Vert \underline{x} - \underline{s}_1 \right\Vert = \left\Vert \underline{x} - \underline{s}_2 \right\Vert \right\}.
\end{equation}
Even though this definition of Voronoi diagrams does not restrict the vectorspace to the $\mathbb{R}^n$ 
and the underlying metric to the usual Euclidian one, 
\begin{equation}
	\left\Vert \underline{x} \right\Vert_2 \ =\ \sqrt{\left<x | x \right>},
\end{equation}
they are nevertheless implied in the rest of this work if nothing else is specified.
Specifically, we thus set $V = \mathbb{R}^2$ and $\left\Vert \cdot \right\Vert = \left\Vert \cdot \right\Vert_2$. 
Please refer to \cite{Icking2001} for other metrics.



\subsection{Voronoi diagrams for vertex sites}
The simplest case is the Voronoi diagram for vertex sites.
For the general case, namely $\mathbb{R}^n$, the bisectors consist of $n-1$-dimensional hyperplanes. 
Specifically for $\mathbb{R}^n$, they are either line segments or infinite lines, depending if the 
corresponding Voronoi region is closed or open, respectively.
An example of two or several vertex sites and their bisectors is shown in Fig. \ref{fig:vertex_voro}.

\begin{figure}[htb]
	\begin{minipage}{1 \textwidth}
		\begin{center}
			\includegraphics[width = 0.35 \textwidth]{figures/vertex_voro}
		\end{center}
		\vspace{0.5cm}
		\begin{center}
			\includegraphics[width = 0.7 \textwidth]{figures/vertex_voro2}
		\end{center}
	\end{minipage}
	\caption[Voronoi diagrams for vertices.]{
		Top panel: Voronoi diagram for two vertex sites, $s_1$ and $s_2$. 
			The bisector, $B\left(s_1, s_2\right)$, separates $\mathbb{R}^2$ 
			into two open Voronoi regions forming half-planes.
		Bottom panel: Voronoi diagram for ten vertex sites, $s_1,\, s_2,\, ...,\, s_{10}$.
		The black lines are the bisectors of the Voronoi regions, where the solid lines are of finite size
		and delimit closed Voronoi regions. The dashed lines are of infinite length and delimit open Voronoi regions.
		The figure has been calculated using the test program that will be described in chapter \ref{sec:tests_hull}.
		\label{fig:vertex_voro}}
\end{figure}


\paragraph{Physical application: Brillouin zones}
Vertex-site Voronoi diagrams are ubiquitous in solid-state physics and all its connected disciplines
like neutron scattering, magnetism, etc., although they are not called so in these fields.
In physics, one usually thinks in terms of the reciprocal (dual, Fourier) space of a crystal lattice, as discussed
in chapter \ref{ch:xtal}. Due to the periodic nature of the crystal and its reciprocal space, one can define a smallest
cell around the sites in reciprocal space (called ``Bragg peaks'') for which all physics is the same, the so-called 
\textit{first Brillouin zone} of the reciprocal lattice \cite[pp. 63-64]{Gross2012}, 
whose definition corresponds to that of the Voronoi region of the Bragg peaks.
The crystal and its reciprocal lattice are assumed to be infinite. This is a good approximation as one usually
considers physics in the Angstrom scale, while the crystals used in neutron scattering usually have volumes on the
$cm^3$ scale. Having an infinite lattice has the effect that the Voronoi diagram does not possess any open regions.
As the crystal is regular and periodic, only one shape of Voronoi region exists, which repeats to fill the
entire reciprocal space without gaps.
Typical examples of Brillouin zone shapes for cubic crystals are shown in Fig. \ref{fig:cubic_bzs}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 0.8 \textwidth]{figures/bz}
	\end{center}
	\caption[Brillouin zones.]{
		First Brillouin zone for
			(a) a simple cubic,
			(b) a body-centred cubic, and
			(c) a face-centred cubic crystal lattice.
		Only the bisectors (blue faces) are shown, the vertex-sites (Bragg peaks) are hidden for clarity.
		Calculated using the \textit{Takin} software \cite{Takin2021, Takin2017, Takin2016}.
		\label{fig:cubic_bzs}}
\end{figure}



\subsection{Voronoi diagrams for line-segment sites}
\label{sec:voro_ls}
We now look at the special case of Voronoi diagrams constructed from line segments.
A description of this case can be found in \cite[Ch. 7.3, pp. 160-163]{Berg2008} and in 
\cite[pp. 242-247]{FUH_geo2020}, whose descriptions we follow in this section.

For this case, the Voronoi region of a line $l_i$ consists of all points in $\mathbb{R}^2$ that 
are closest to $l_i$. The bisector is the boundary between the Voronoi regions of two line segments 
$l_i$ and $l_j$, $i \neq j$,
and is the curve of equal distance between the two line segments $l_i$ and $l_j$.
Its shape is either linear or quadratic, where, in the linear case, the bisector curve can also be either
finite or infinite \cite[pp. 243-244]{FUH_geo2020}.

A linear bisector is obtained for the distance calculated between two line segment endpoints or between two inner 
points on the line segments which are not the endpoints.
This can easily be seen, because, (a) in the case of two endpoints, the middle perpendicular line between these 
two points is equidistant to them; and (b) in the case of two line segments, the angular bisector of the two lines is
equidistant to them \cite[pp. 243-244]{FUH_geo2020}.
On the other hand, the bisector curve segment follows a parabolic shape if the distance is calculated 
between a line segment endpoint and one inner point of the other segment. This is the same as the bisector between
a point and a line and it parabolic distance is shown in \cite[pp. 260-261]{FUH_geo2020}.
An example of two or several line segment sites and their bisectors is shown in Fig. \ref{fig:linesegs_voro}.

\begin{figure}[h]
	\begin{minipage}{1 \textwidth}
		\begin{center}
			\includegraphics[width = 0.7 \textwidth]{figures/linesegs}
		\end{center}
		\vspace{0.5cm}
	\end{minipage}
	\begin{minipage}{1 \textwidth}
		\vspace{0.25cm}
		\begin{center}
			\includegraphics[width = 0.95 \textwidth]{figures/linesegs2}
		\end{center}
	\end{minipage}
	\caption[Voronoi diagrams for line segments.]{
		Top panel: Voronoi regions for two line segments, $l_1$ and $l_2$.
		Bottom panel: Voronoi regions for five line segments, $l_1,\, l_2,\, ...,\, l_5$.
		The line segments and their endpoints are marked in blue. The small red points represent the Voronoi vertices.
		The black lines are the bisectors of the Voronoi regions, where the solid lines delimit finite and the dashed lines
		infinite regions. Helper lines are marked in red. The figure has been calculated using the line segments
		test program which will be described in chapter \ref{sec:tests_linesegs}. The program uses 
		the \textit{Boost.Polygon} library \cite{web_boost_polygon_voronoi}.
		\label{fig:linesegs_voro}}
\end{figure}


\subsection{Software libraries}
A stable and efficient C/C++ library for calculating Voronoi diagram in $\mathbb{R}^n$ is the popular and very 
high-quality \textit{QHull} by C. B. Barber \cite{web_qhull}. While it does only calculate 
the Voronoi diagrams for vertices, and not for line segments, it is also capable of calculation the Delaunay
triangulation and -- as the name implies -- convex hull of the sites.

Several libraries for calculating the line segment Voronoi diagrams in $\mathbb{R}^2$ exist, noteworthy 
are \textit{VRONI} by M. Held \cite{Held2001}, \textit{OpenVoronoi} by A. E. Wallin \cite{web_openvoronoi}, \textit{VoroLS} 
by W. Schumann \cite{DiplomaSchumann}, as well as the Voronoi calculator \cite{web_boost_polygon_voronoi} 
by A. Sydorchukof, which is part of the \textit{Boost.Polygon}  \cite{web_boost_polygon, Simonson2009} 
C++ library.
The first three are feasible for the present project, though: 
\begin{itemize}
	\item \textit{VRONI} \cite{Held2001} is reported in a paper, but is neither freely available 
		nor under a suitable open-source license.
	\item The opposite is true for \textit{OpenVoronoi} \cite{web_openvoronoi}: 
		It is available under an open-source license, but our first tests deemed it too unstable 
		for use in a production-quality software. 
		The source code for our tests can be found in the function \lstinline[language=C++]|geo::calc_voro_ovd()|, 
		which resides in file \lstinline|./src/libs/hull.h| of the accompanying code. 
		The source code for the test tool itself is located in: \lstinline|./src/tools/lines.cpp|.
	\item \textit{VoroLS} \cite{DiplomaSchumann} is stable and does even handle intersecting lines, but is a \textit{Java}
		software, not a library, and is not under an open-source license.
	\item All requirements were met by \textit{Boost.Polygon} \cite{web_boost_polygon}, though, and we will use 
		this library for the calculations of the present work.
		\textit{Boost.Polygon}  uses Fortune's sweep algorithm \cite{Fortune1987} to construct 
		the Voronoi diagram and is internally based on integers coordinates \cite{web_boost_polygon}.
		The reliance on integer coordinate representation is also responsible for \textit{Boost.Polygon}'s 
		inability to handle intersecting lines, because the intersection point may be at a non-integer coordinate. 
		Intersecting lines need to be carefully filtered out, because they can unfortunately cause the 
		\textit{Boost.Polygon} library to either crash, hang, or yield wrong bisectors.
\end{itemize}




\section{Graphs}
\label{sec:graphs}
Another crucial concept for path-finding on a mesh of nodes is the graph.
A good review of graph theory can be found in Ref. \cite{FUH_algo_graphs_2021},
which we will follow in this section.

A graph is a tuple $G = \left(V, E\right)$ of a set of vertices $V$ and edges $E \subseteq V \times V$ 
connecting the vertices. For the present case, we only consider directed and weighted graphs 
\cite[pp. 1-3]{FUH_algo_graphs_2021}.
\textit{Directed} means that the existence of an edge $e = \left(v_1, v_2\right)$ connecting vertices 
$v_1 \in V$ and $v_2 \in V$ does not imply the existence of the reverse connection $e'= \left(v_2, v_1\right)$
from $v_2$ to $v_1$. That would only be the case in an undirected graph.
\textit{Weighted} means that a weight function $w: E \rightarrow \mathbb{R}$ exists which maps each 
edge $e \in E$ to a weight factor $w\left(e\right) \in \mathbb{R}$ quantifying that edge. 
For example, the weight factors could be distances for a graph whose vertices correspond to Cartesian coordinates.
Another restriction that will be used in this work is the exclusion of loops in the graph, i.e.
no edges $e = \left(v, v\right)$ connecting a vertex $v \in V$ to itself will be allowed.
Finally, we define a path in the graph as a tuple of $n$ vertices $p = \left(v_1, v_2, ..., v_n\right)$
where subsequent vertices $v_i$ and $v_{i+1}$, $i \in \left[1, n\right]$, are connected by an edge and 
where each vertex in the tuple is unique, i.e. $v_i \neq v_j$ for $i \neq j$.
Specifically, this signifies that there are no loops and no vertex is visited multiple times upon 
traversal of the path.
An example for a graph is shown in Fig. \ref{fig:example_graph}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 1 \textwidth]{figures/example_graph}
	\end{center}
	\caption[Example graph.]{
		Example of a directed, weighted graph containing five vertices, $v_1$, $v_2$, ..., $v_5$.
		The figure has been drawn using the \textit{Dot} tool from the \textit{Graphviz} software \cite{Ellson2003}.
		\label{fig:example_graph}}
\end{figure}


There are two common data structures to store graphs, the adjacency matrix and the adjacency list, which are
both discussed in general and in terms of complexity in Ref. \cite[pp. 3-5]{FUH_algo_graphs_2021}.
The adjacency matrix for a graph with $n$ vertices is an $n \times n$ matrix that stores the 
weights $w\left(e_{ij}\right)$ for edge $e_{ij}$ between vertices $v_i$ and $v_j$ in its elements,
where either $0$ or a special \textit{null} symbol means that the corresponding edge does not exist.
The adjacency list for a graph with $n$ vertices is an array with $n$ elements $l_i$ which point 
to the head of a (doubly) linked list whose entries contain pointers to all the vertices $v_j$ that are reachable 
from vertex $v_i$ along with the weight factors for edge $e_{ij}$.
Table \ref{tab:example_graph_structure} shows an example for an adjacency matrix and an adjacency list.

\begin{table}[h]
	\centering
	\begin{tabular}{|c|ccccc|}
			\hline
			      & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			$v_1$ &  null &     1 &  null &     9 &    10 \tabularnewline
			$v_2$ &  null &  null &     3 &     7 &  null \tabularnewline
			$v_3$ &    10 &  null &  null &     1 &     2 \tabularnewline
			$v_4$ &  null &     1 &  null &  null &     2 \tabularnewline
			$v_5$ &  null &  null &  null &  null &  null \tabularnewline
			\hline
	\end{tabular}
	\hspace{1cm}
	\begin{tabular}{|c|c|ccccc|}
			\cline{1-1} \cline{3-7}
			$v_1$ &  $\rightarrow$ &  $v_2\, [1]$ &  $\leftrightarrow$ &  $v_4\, [9]$ &  $\leftrightarrow$  & $v_5\, [10]$ \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_2$ &  $\rightarrow$ &  $v_3\, [3]$ &  $\leftrightarrow$ &  $v_4\, [7]$ &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_3$ &  $\rightarrow$ &  $v_1\, [10]$ &  $\leftrightarrow$ &  $v_4\, [1]$ &  $\leftrightarrow$  & $v_5\, [2]$ \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_4$ &  $\rightarrow$ &  $v_2\, [1]$ & $\leftrightarrow$  &  $v_5\, [2]$ &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_5$ &  $\rightarrow$ & null &   &   &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
	\end{tabular}
	\caption[Adjacency matrix and list.]{
		Adjacency matrix (left) and adjacency list (right) for the example graph shown in Fig. \ref{fig:example_graph}.
		For the adjacency matrix, the weight factors directly form the entries, whereas for the adjacency list, 
		the weight factors are stored alongside the vertex entries and are here shown in square brackets.
		These tables follow the design of Ref. \cite[pp. 4, table 4.1]{FUH_algo_graphs_2021}.}
	\label{tab:example_graph_structure}
\end{table}



\subsection{Dijkstra's algorithm}
\label{sec:dijkstra}
TODO
