%
% gl
% @author Tobias Weber <tweber@ill.fr>
% @date aug-2021
% @license see 'LICENSE' file
%

\chapter{Basic Concepts, Algorithms and Data Structures}
\label{ch:algos}
The  path-finding algorithm and implementation, that will be presented in the following chapters,
employs several different concepts, data structures and methods.
In this chapter, these basic building blocks are reviewed in a general manner.


\section{Voronoi diagrams}
\label{sec:voro}
As we will see in the next chapter, a concept that will play a central role for the path-finding 
algorithm of this work is the Voronoi diagram.
A good review of Voronoi diagrams is given in Ref. \cite[Ch. 7, pp. 147-171]{Berg2008} 
and in \cite[Ch. 5, pp. 209f]{FUH_geo2020}, which we follow in this chapter.

Starting with some basic definitions, a \textit{Voronoi diagram} is a set of 
\textit{bisectors}, $B\left(\underline{x},\, \underline{y}\right)$, separating \textit{Voronoi regions}.
A Voronoi region names the set of points $\underline{x}$ in a vectorspace $V$ that are closest to 
a given site $\underline{s}$ under a given metric $\left\Vert \cdot \right\Vert$, which measures distances in $V$.
The site can either be isolated vertices, lines or any other finite object.
Formally, the bisector between two sites $\underline{s}_1$ and $\underline{s}_2$ is, 
generalising from \cite[p. 140]{Icking2001},
\begin{equation}
	B\left(\underline{s}_1,\, \underline{s}_2\right)\ =\ \left\{ \underline{x} \in V \ |\ 
		\left\Vert \underline{x} - \underline{s}_1 \right\Vert = \left\Vert \underline{x} - \underline{s}_2 \right\Vert \right\}.
\end{equation}
Even though this definition of Voronoi diagrams does not restrict the vectorspace to the $\mathbb{R}^n$ 
and the underlying metric to the usual Euclidian one, 
\begin{equation}
	\left\Vert \underline{x} \right\Vert_2 \ =\ \sqrt{\left<x | x \right>},
\end{equation}
they are nevertheless implied in the rest of this work if nothing else is specified.
Specifically, we thus set $V = \mathbb{R}^2$ and $\left\Vert \cdot \right\Vert = \left\Vert \cdot \right\Vert_2$. 
Please refer to \cite{Icking2001} for other metrics.



\subsection{Voronoi diagrams for vertex sites}
The simplest case is the Voronoi diagram for vertex sites.
For the general case, namely $\mathbb{R}^n$, the bisectors consist of $n-1$-dimensional hyperplanes. 
Specifically for $\mathbb{R}^n$, they are either line segments or infinite lines, depending if the 
corresponding Voronoi region is closed or open, respectively.
An example of two or several vertex sites and their bisectors is shown in Fig. \ref{fig:vertex_voro}.

\begin{figure}[htb]
	\begin{minipage}{1 \textwidth}
		\begin{center}
			\includegraphics[width = 0.35 \textwidth]{figures/vertex_voro}
		\end{center}
		\vspace{0.5cm}
		\begin{center}
			\includegraphics[width = 0.7 \textwidth]{figures/vertex_voro2}
		\end{center}
	\end{minipage}
	\caption[Voronoi diagrams for vertices.]{
		Top panel: Voronoi diagram for two vertex sites, $s_1$ and $s_2$. 
			The bisector, $B\left(s_1, s_2\right)$, separates $\mathbb{R}^2$ 
			into two open Voronoi regions forming half-planes.
		Bottom panel: Voronoi diagram for ten vertex sites, $s_1,\, s_2,\, ...,\, s_{10}$.
		The black lines are the bisectors of the Voronoi regions, where the solid lines are of finite size
		and delimit closed Voronoi regions. The dashed lines are of infinite length and delimit open Voronoi regions.
		The figure has been calculated using the test program that will be described in chapter \ref{sec:tests_hull}.
		\label{fig:vertex_voro}}
\end{figure}


\paragraph{Physical application: Brillouin zones}
Vertex-site Voronoi diagrams are ubiquitous in solid-state physics and all its connected disciplines
like neutron scattering, magnetism, etc., although they are not called so in these fields.
In physics, one usually thinks in terms of the reciprocal (dual, Fourier) space of a crystal lattice, as discussed
in chapter \ref{ch:xtal}. Due to the periodic nature of the crystal and its reciprocal space, one can define a smallest
cell around the sites in reciprocal space (called ``Bragg peaks'') for which all physics is the same, the so-called 
\textit{first Brillouin zone} of the reciprocal lattice \cite[pp. 63-64]{Gross2012}, 
whose definition corresponds to that of the Voronoi region of the Bragg peaks.
The crystal and its reciprocal lattice are assumed to be infinite. This is a good approximation as one usually
considers physics in the Angstrom scale, while the crystals used in neutron scattering usually have volumes on the
$cm^3$ scale. Having an infinite lattice has the effect that the Voronoi diagram does not possess any open regions.
As the crystal is regular and periodic, only one shape of Voronoi region exists, which repeats to fill the
entire reciprocal space without gaps.
Typical examples of Brillouin zone shapes for cubic crystals are shown in Fig. \ref{fig:cubic_bzs}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 0.8 \textwidth]{figures/bz}
	\end{center}
	\caption[Brillouin zones.]{
		First Brillouin zone for
			(a) a simple cubic,
			(b) a body-centred cubic, and
			(c) a face-centred cubic crystal lattice.
		Only the bisectors (blue faces) are shown, the vertex-sites (Bragg peaks) are hidden for clarity.
		Calculated using the \textit{Takin} software \cite{Takin2021, Takin2017, Takin2016}.
		\label{fig:cubic_bzs}}
\end{figure}



\subsection{Voronoi diagrams for line-segment sites}
\label{sec:voro_ls}
We now look at the special case of Voronoi diagrams constructed from line segments.
A description of this case can be found in \cite[Ch. 7.3, pp. 160-163]{Berg2008} and in 
\cite[pp. 242-247]{FUH_geo2020}, whose descriptions we follow in this section.

For this case, the Voronoi region of a line $l_i$ consists of all points in $\mathbb{R}^2$ that 
are closest to $l_i$. The bisector is the boundary between the Voronoi regions of two line segments 
$l_i$ and $l_j$, $i \neq j$,
and is the curve of equal distance between the two line segments $l_i$ and $l_j$.
Its shape is either linear or quadratic, where, in the linear case, the bisector curve can also be either
finite or infinite \cite[pp. 243-244]{FUH_geo2020}.

A linear bisector is obtained for the distance calculated between two line segment endpoints or between two inner 
points on the line segments which are not the endpoints.
This can easily be seen, because, (a) in the case of two endpoints, the middle perpendicular line between these 
two points is equidistant to them; and (b) in the case of two line segments, the angular bisector of the two lines is
equidistant to them \cite[pp. 243-244]{FUH_geo2020}.
On the other hand, the bisector curve segment follows a parabolic shape if the distance is calculated 
between a line segment endpoint and one inner point of the other segment. This is the same as the bisector between
a point and a line and it parabolic distance is shown in \cite[pp. 260-261]{FUH_geo2020}.
An example of two or several line segment sites and their bisectors is shown in Fig. \ref{fig:linesegs_voro}.

\begin{figure}[h]
	\begin{minipage}{1 \textwidth}
		\begin{center}
			\includegraphics[width = 0.7 \textwidth]{figures/linesegs}
		\end{center}
		\vspace{0.5cm}
	\end{minipage}
	\begin{minipage}{1 \textwidth}
		\vspace{0.25cm}
		\begin{center}
			\includegraphics[width = 0.95 \textwidth]{figures/linesegs2}
		\end{center}
	\end{minipage}
	\caption[Voronoi diagrams for line segments.]{
		Top panel: Voronoi regions for two line segments, $l_1$ and $l_2$.
		Bottom panel: Voronoi regions for five line segments, $l_1,\, l_2,\, ...,\, l_5$.
		The line segments and their endpoints are marked in blue. The small red points represent the Voronoi vertices.
		The black lines are the bisectors of the Voronoi regions, where the solid lines delimit finite and the dashed lines
		infinite regions. Helper lines are marked in red. The figure has been calculated using the line segments
		test program which will be described in chapter \ref{sec:tests_linesegs}. The program uses 
		the \textit{Boost.Polygon} library \cite{web_boost_polygon_voronoi}.
		\label{fig:linesegs_voro}}
\end{figure}


\subsection{Software libraries}
A stable and efficient C/C++ library for calculating Voronoi diagram in $\mathbb{R}^n$ is the popular and very 
high-quality \textit{QHull} by C. B. Barber \cite{web_qhull}. While it does only calculate 
the Voronoi diagrams for vertices, and not for line segments, it is also capable of calculation the Delaunay
triangulation and -- as the name implies -- convex hull of the sites.

Several libraries for calculating the line segment Voronoi diagrams in $\mathbb{R}^2$ exist, noteworthy 
are \textit{VRONI} by M. Held \cite{Held2001}, \textit{OpenVoronoi} by A. E. Wallin \cite{web_openvoronoi}, \textit{VoroLS} 
by W. Schumann \cite{DiplomaSchumann}, as well as the Voronoi calculator \cite{web_boost_polygon_voronoi} 
by A. Sydorchukof, which is part of the \textit{Boost.Polygon}  \cite{web_boost_polygon, Simonson2009} 
C++ library.
The first three are not feasible for the present project, though: 
\begin{itemize}
	\item \textit{VRONI} \cite{Held2001} is reported in a paper, but is neither freely available 
		nor under a suitable open-source license.
	\item The opposite is true for \textit{OpenVoronoi} \cite{web_openvoronoi}: 
		It is available under an open-source license, but our first tests deemed it too unstable 
		for use in a production-quality software. 
		The source code for our tests can be found in the function \lstinline[language=C++]|geo::calc_voro_ovd()|, 
		which resides in file \lstinline|./src/libs/hull.h| of the accompanying code. 
		The source code for the test tool itself is located in: \lstinline|./src/tools/lines.cpp|.
	\item \textit{VoroLS} \cite{DiplomaSchumann} is stable and does even handle intersecting lines, but is a \textit{Java}
		software, not a library, and is not under an open-source license.
	\item All requirements were met by \textit{Boost.Polygon} \cite{web_boost_polygon}, though, and we will use 
		this library for the calculations of the present work.
		\textit{Boost.Polygon}  uses Fortune's sweep algorithm \cite{Fortune1987} to construct 
		the Voronoi diagram and is internally based on integers coordinates \cite{web_boost_polygon}.
		The reliance on integer coordinate representation is also responsible for \textit{Boost.Polygon}'s 
		inability to handle intersecting lines, because the intersection point may be at a non-integer coordinate. 
		Intersecting lines need to be carefully filtered out, because they can unfortunately cause the 
		\textit{Boost.Polygon} library to either crash, hang, or yield wrong bisectors.
\end{itemize}




\section{Graphs}
\label{sec:graphs}
Another crucial concept for path-finding on a mesh of nodes is the graph.
A good review of graph theory can be found in Ref. \cite{FUH_algo_graphs_2021},
which we will follow in this section.

A graph is a tuple $G = \left(V, E\right)$ of a set of vertices $V$ and edges $E \subseteq V \times V$ 
connecting the vertices. For the present case, we only consider directed and weighted graphs 
\cite[pp. 1-3]{FUH_algo_graphs_2021}.
\textit{Directed} means that the existence of an edge $e = \left(v_1, v_2\right)$ connecting vertices 
$v_1 \in V$ and $v_2 \in V$ does not imply the existence of the reverse connection $e'= \left(v_2, v_1\right)$
from $v_2$ to $v_1$. That would only be the case in an undirected graph.
\textit{Weighted} means that a weight function $w: E \rightarrow \mathbb{R}$ exists which maps each 
edge $e \in E$ to a weight factor $w\left(e\right) \in \mathbb{R}$ quantifying that edge. 
For example, the weight factors could be distances for a graph whose vertices correspond to Cartesian coordinates.
Another restriction that will be used in this work is the exclusion of loops in the graph, i.e.
no edges $e = \left(v, v\right)$ connecting a vertex $v \in V$ to itself will be allowed.
Finally, we define a path in the graph as a tuple of $n$ vertices $p = \left(v_1, v_2, ..., v_n\right)$
where subsequent vertices $v_i$ and $v_{i+1}$, $i \in \left[1, n\right]$, are connected by an edge and 
where each vertex in the tuple is unique, i.e. $v_i \neq v_j$ for $i \neq j$.
Specifically, this signifies that there are no loops and no vertex is visited multiple times upon 
traversal of the path.
An example for a graph is shown in Fig. \ref{fig:example_graph}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 1 \textwidth]{figures/example_graph}
	\end{center}
	\caption[Example graph.]{
		Example of a directed, weighted graph containing five vertices, $v_1$, $v_2$, ..., $v_5$.
		The figure has been drawn using the \textit{Dot} tool from the \textit{Graphviz} software \cite{Ellson2003}.
		\label{fig:example_graph}}
\end{figure}


\paragraph{Data structures}
There are two common data structures to store graphs, the adjacency matrix and the adjacency list, which are
both discussed in general and in terms of complexity in Ref. \cite[pp. 3-5]{FUH_algo_graphs_2021}.
The adjacency matrix for a graph with $n$ vertices is an $n \times n$ matrix that stores the 
weights $w\left(e_{ij}\right)$ for edge $e_{ij}$ between vertices $v_i$ and $v_j$ in its elements,
where either $0$ or a special \textit{null} symbol means that the corresponding edge does not exist.
The adjacency list for a graph with $n$ vertices is an array with $n$ elements $l_i$ which point 
to the head of a (doubly) linked list whose entries contain pointers to all the vertices $v_j$ that are reachable 
from vertex $v_i$ along with the weight factors for edge $e_{ij}$.
Table \ref{tab:example_graph_structure} shows an example for an adjacency matrix and an adjacency list.

\begin{table}[h]
	\centering
	\begin{tabular}{|c|ccccc|}
			\hline
			      & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			$v_1$ &  null &     1 &  null &     9 &    10 \tabularnewline
			$v_2$ &  null &  null &     3 &     7 &  null \tabularnewline
			$v_3$ &    10 &  null &  null &     1 &     2 \tabularnewline
			$v_4$ &  null &     1 &  null &  null &     2 \tabularnewline
			$v_5$ &  null &  null &  null &  null &  null \tabularnewline
			\hline
	\end{tabular}
	\hspace{1cm}
	\begin{tabular}{|c|c|ccccc|}
			\cline{1-1} \cline{3-7}
			$v_1$ &  $\rightarrow$ &  $v_2\, [1]$ &  $\leftrightarrow$ &  $v_4\, [9]$ &  $\leftrightarrow$  & $v_5\, [10]$ \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_2$ &  $\rightarrow$ &  $v_3\, [3]$ &  $\leftrightarrow$ &  $v_4\, [7]$ &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_3$ &  $\rightarrow$ &  $v_1\, [10]$ &  $\leftrightarrow$ &  $v_4\, [1]$ &  $\leftrightarrow$  & $v_5\, [2]$ \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_4$ &  $\rightarrow$ &  $v_2\, [1]$ & $\leftrightarrow$  &  $v_5\, [2]$ &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
			$v_5$ &  $\rightarrow$ & null &   &   &   &  \tabularnewline
			\cline{1-1} \cline{3-7}
	\end{tabular}
	\caption[Adjacency matrix and list.]{
		Adjacency matrix (left) and adjacency list (right) for the example graph shown in Fig. \ref{fig:example_graph}.
		For the adjacency matrix, the weight factors directly form the entries, whereas for the adjacency list, 
		the weight factors are stored alongside the vertex entries and are here shown in square brackets.
		These tables follow the design of Ref. \cite[pp. 4, table 4.1]{FUH_algo_graphs_2021}.}
	\label{tab:example_graph_structure}
\end{table}



\subsection{Shortest path and Dijkstra's algorithm}
\label{sec:dijkstra}
\paragraph{Shortest path}
The shortest path in a graph is the path between two vertices which minimises the sum of the weights
of all edges that are traversed along the way.
Two general classes of algorithms for finding the shortest path in a graph exist.
The first class of algorithms solves the so-called \textit{single source shortest path (SSSP)} problem,
which calculates the shortest paths from one source vertex to all other vertices \cite[pp. 273-297]{Erickson2019}.
The second class of algorithms solves the \textit{all pairs shortest path (APSP)} problem, which calculates
all possible pairs of shortest paths between any two vertices in the graph \cite[pp. 309-320]{Erickson2019}.
Noteworthy representatives of these two classes are the Bellman-Ford \cite[pp. 11-14]{FUH_algo_graphs_2021} 
and the Dijkstra algorithm \cite[pp. 14-18]{FUH_algo_graphs_2021} for SSSP, 
as well as the Johnson \cite[pp. 19-21]{FUH_algo_graphs_2021} 
and the Floyd-Warshall algorithm \cite[pp. 21-24]{FUH_algo_graphs_2021} for APSP.

For the case presented in the following chapters we are interested in calculating a single path between 
a source and target point and will thus need to solve an SSSP problem.
To that end we choose Dijkstra's algorithm, because in the best case it can be implemented 
in $\mathcal{O}\left( n_e \log_2 n_v \right)$ time and $\mathcal{O}\left( n_v \right)$ space 
complexity when using a heap as internal data structure \cite[pp. 17-18]{FUH_algo_graphs_2021}, 
where $n_v$ is the number of vertices in the graph, and $n_e$ the number of edges.
The Bellman-Ford algorithm would be less efficient, with time and storage complexities of 
$\mathcal{O}\left( n_v n_e \right)$ and $\mathcal{O}\left( n_v \right)$, respectively 
\cite[pp. 13]{FUH_algo_graphs_2021}.

\paragraph{Dijkstra's algorithm}
Following the pseudo-code description in Ref. \cite[p. 17]{FUH_algo_graphs_2021}, Dijkstra's algorithm
works by inserting all vertices of the graph into a priority search queue, where they are sorted according 
to distances values to the start vertex that are to be determined and which are initially set to $0$ for
the start vertex and to infinity for all other vertices.
As long as the priority queue is not empty, its top vertex, i.e. the one with the lowest distance value, 
$v_i$, is removed from it. 
It is tested for each of $v_i$'s outgoing edges, $e_{ij}$, if the path length from the start vertex to 
vertex $v_j$ (saved as the distance value for $v_j$) becomes smaller when going over vertex $v_i$ (determined
as the distance value for $v_i$ plus the weight of the edge $e_{ij}$). 
If so, the distance value for $v_j$ is set to this shorter path length and $v_i$ is remembered as the
predecessor of $v_j$ along the path.
As discussed before, the priority search queue should use a heap as its internal data structure for
optimal run time.

It should be noted that while this is the textbook example of Dijkstra's algorithm, J. Erickson describes
a slightly modified version which is more general in its support of negative edge weights and which is not
less efficient than the standard version \cite[pp. 284-288]{Erickson2019}:
This modified version does not directly initialise the priority search queue with all vertices beforehand, 
but only with the start vertex (using, as before, a distance of $0$ to itself).
It inserts the neighbour vertices $v_j$ (as defined above) only if they are discovered to lead to a shorter 
path in the iteration of all neighbours of the current top vertex in the queue, $v_i$. Full pseudo-code 
for that can be found in Ref. \cite[p. 285]{Erickson2019}.

\paragraph{Example}
The two variants of Dijkstra's algorithm are best demonstrated using an example.
In table \ref{tab:example_dijk} we show each step of the algorithm by finding the shortest
paths from start point $v_1$ of the graph in Fig. \ref{fig:example_graph}.
From the final results, a shortest path can be constructed by traversing the predecessors in
reverse. For instance, for the shortest path from $v_1$ to $v_5$ we look at the predecessor
of $v_5$, which is $v_3$. Next, the predecessor of $v_3$ is $v_2$ and that of $v_2$ is $v_1$.
The shortest path is thus $v_1$, $v_2$, $v_3$, $v_5$.

\begin{table}[h]
	\begin{minipage}[t]{0.45 \textwidth}
	Dijkstra's algorithm \cite[p. 17]{FUH_algo_graphs_2021} run:
	\begin{itemize}
	\item Initialisation.
	
	\begin{tabular}{|c|ccccc|}
			\hline
			     Heap & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Distances &  $0$  &  $\infty$ &  $\infty$ &     $\infty$ &    $\infty$ \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  - &  - &     - &    - \tabularnewline
			\hline
	\end{tabular}
	

	\item Iteration 1: Outgoing edges from $v_1$ to $v_2$, $v_4$, and $v_5$
		all lead to shorter paths.
	
	\begin{tabular}{|c|cccc|}
			\hline
			     Heap & $v_2$ & $v_4$ & $v_3$ & $v_5$ \tabularnewline
			\hline
			Distances &  $1$  &  $9$ &  $\infty$ &     $10$  \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  - &     $v_1$ &    $v_1$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 2: Outgoing edges from $v_2$ to $v_3$ and $v_4$
		both lead to shorter paths.
	
	\begin{tabular}{|c|ccc|}
			\hline
			     Heap & $v_3$ & $v_5$ & $v_4$  \tabularnewline
			\hline
			Distances &  $4$  &  $10$ &  $8$  \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_2$ &    $v_1$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 3: Outgoing edges from $v_3$ to $v_4$ and $v_5$
		both lead to shorter paths.
	
	\begin{tabular}{|c|cc|}
			\hline
			     Heap & $v_4$ & $v_5$  \tabularnewline
			\hline
			Distances &  $5$  &  $6$   \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_3$ &    $v_3$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 4: Outgoing edges from $v_4$ to $v_2$ and $v_5$
		do not lead shorter paths.
	
	\begin{tabular}{|c|c|}
			\hline
			     Heap & $v_5$ \tabularnewline
			\hline
			Distance &  $6$   \tabularnewline
			\hline
	\end{tabular}


	\item Finalisation: No outgoing edges from $v_5$.
	
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_3$ &    $v_3$ \tabularnewline
			Distances &  $0$  &  $1$ &  $4$ &     $5$ &    $6$ \tabularnewline
			\hline
	\end{tabular}

	\end{itemize}
	\end{minipage}
	%
	%
	%
	%
	\begin{minipage}[t]{0.45 \textwidth}
	%\footnotesize
	Modified Dijkstra's algorithm \cite[p. 285]{Erickson2019} run:
	\begin{itemize}
	\item Initialisation.
	
	\begin{tabular}{|c|c|}
			\hline
			     Heap & $v_1$ \tabularnewline
			\hline
			Distance &  $0$  \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  - &  - &     - &    - \tabularnewline
			\hline
	\end{tabular}
	

	\item Iteration 1: Outgoing edges from $v_1$ to $v_2$, $v_4$, and $v_5$
		all lead to shorter paths.
	
	\begin{tabular}{|c|ccc|}
			\hline
			     Heap & $v_2$ & $v_5$ & $v_4$ \tabularnewline
			\hline
			Distances &  $1$  &  $10$ &  $9$ \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  - &     $v_1$ &    $v_1$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 2: Outgoing edges from $v_2$ to $v_3$ and $v_4$
		both lead to shorter paths.
	
	\begin{tabular}{|c|ccc|}
			\hline
			     Heap & $v_3$ & $v_5$  &  $v_4$  \tabularnewline
			\hline
			Distances &  $4$  &  $10$  &  $8$  \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_2$ &    $v_1$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 3: Outgoing edges from $v_3$ to $v_4$ and $v_5$
		both lead to shorter paths.
	
	\begin{tabular}{|c|cc|}
			\hline
			     Heap & $v_4$ & $v_5$  \tabularnewline
			\hline
			Distances &  $5$  &  $6$   \tabularnewline
			\hline
	\end{tabular}\\
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_3$ &    $v_3$ \tabularnewline
			\hline
	\end{tabular}


	\item Iteration 4: No outgoing edges from $v_4$ to $v_2$ and $v_5$
		do not lead to shorter paths.
	
	\begin{tabular}{|c|c|}
			\hline
			     Heap & $v_5$ \tabularnewline
			\hline
			Distance &  $6$   \tabularnewline
			\hline
	\end{tabular}


	\item Finalisation: No outgoing edges from $v_5$.
	
	\begin{tabular}{|c|ccccc|}
			\hline
			     Vertices & $v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \tabularnewline
			\hline
			Predecessors &  -  &  $v_1$ &  $v_2$ &     $v_3$ &    $v_3$ \tabularnewline
			Distances &  $0$  &  $1$ &  $4$ &     $5$ &    $6$ \tabularnewline
			\hline
	\end{tabular}

	\end{itemize}
	\end{minipage}

	\caption[Example for Dijkstra's algorithm]{
	Example runs of Dijkstra's algorithm (left column) and its modified version (right column)
	for the graph shown in Fig. \ref{fig:example_graph} and start vertex $v_1$.
	Note that from iteration 2 on, both variants have converged to the same results.}
	\label{tab:example_dijk}
\end{table}
