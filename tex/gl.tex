%
% gl
% @author Tobias Weber <tweber@ill.fr>
% @date aug-2021
% @license see 'LICENSE' file
%

\chapter{Mathematics for 3-d Graphics}
\label{ch:gl}

The software of this work uses \textit{OpenGL} \cite{web_OpenGL} in its main graphical user interface (GUI).
This appendix chapter adds technical details to the general descriptions in chapter \ref{sec:gui_gl}.
A comprehensive overview of \textit{OpenGL} and the mathematics involved can be found in Ref. \cite{TODO}.



\section{Coordinate systems and transformations}
To draw a three-dimensional object onto the screen, three principal coordinate systems are typically maintained,
namely the coordinate system of the object, the system of the camera, as well as screen and window coordinates.
The vertices of the 3-d object, $\left|x\right>$ , are thus transformed into a window's 2-d pixels by using four
transformation matrices,
\begin{equation}
	\boxed{\left|x_{\mathrm{viewport}}\right> \ =\ W \cdot P \cdot V \cdot  M \cdot  \left| x_{\mathrm{model}} \right>,}
	\label{eq:gl_mvp}
\end{equation}
where $M$ represents the model's local matrix (used, for example, to spin the object around one of its axes),
$V$ is the view matrix given by the camera's coordinate system which transforms local object coordinates into
a global coordinate system. These matrices take the form described in section \ref{sec:gl_trafos}.
$P$ projects the three-dimensional scene onto the two-dimensional plane representing the screen \cite{web_gl_ortho, web_gl_perspective} and is described in section \ref{sec:gl_projs}. 
Finally, $W$ is the window or viewport matrix which scales and translates the projected screen coordinates 
into the pixel coordinates of the display window \cite{web_gl_viewport}, it is discussed in section \ref{sec:gl_viewport}.

Historically, \textit{OpenGL} used a fixed transformation and lighting pipeline \cite{wiki_gl_history} for
these transformations. The pipeline maintained different stacks of matrices for the combined model-view and
projection matrices \cite{web_gl_matrixmode}.
Modern \textit{OpenGL} \cite{web_OpenGL} versions and its successor \textit{Vulkan} \cite{web_Vulkan} do not 
use internal matrix stacks anymore, instead all transformation and lighting operations are programmable through 
small \textit{shader} programs that are directly executed on the graphics processing unit (GPU) \cite{wiki_gl_history}
and are written in a \textit{C}-like language \cite{wiki_glsl}.
While the transformation given by Eq. \ref{eq:gl_mvp} is not fixed anymore, its form is usually maintained
in the shaders by the user. More information on the rendering pipeline and the shaders is given in 
section \ref{sec:gl_shaders}.

The transformation inverse to Eq. \ref{eq:gl_mvp} is of importance to be able to select objects in the three-dimensional
scene by mouse. To that end, a line is calculated by ``unprojecting'' the mouse position in window coordinates
onto the near and far planes of the view frustum and calculating the intersection of the line through these
two points with the scene geometry \cite{web_gl_unproject}. The operation is given by:
\begin{equation}
	\left|x_{\mathrm{model}}\right> \ =\ M^{-1} \cdot V^{-1} \cdot P^{-1} \cdot  W^{-1} \cdot  \left| x_{\mathrm{viewport}} \right>,
\end{equation}
and normalising $\left|x_{\mathrm{model}}\right>$ by its fourth (homogeneous) component \cite{web_gl_unproject}.



\section{3-d transformations}
\label{sec:gl_trafos}
To simplify the calculations when translations are involved, \textit{OpenGL} uses homogeneous coordinates.
Homogeneous coordinates append a fourth component to the three-dimensional vectors, which is set to zero for
directions and to one for vertices.


% -----------------------------------------------------------------------------
% scaling
% -----------------------------------------------------------------------------
\subsection{Translation}
Vertices can thus be translated by left-multiplying with a matrix whose fourth column represents the translation
vector:
\begin{equation}
	\left( \begin{array}{c} x + t_x \\ y + t_y \\ z + t_z \\ 1 \end{array} \right) 
	\ =\  
	\left( \begin{array}{cccc} 
		1 & 0 & 0 & t_x \\
		0 & 1 & 0 & t_y \\
		0 & 0 & 1 & t_z \\
		0 & 0 & 0 & 1
	\end{array} \right) \cdot
	\left( \begin{array}{c} x \\ y \\ z \\ 1 \end{array} \right).
\end{equation}
Not that direction vectors, which have their fourth component zero, are not affected by a translation.
% -----------------------------------------------------------------------------


% -----------------------------------------------------------------------------
% scaling
% -----------------------------------------------------------------------------
\subsection{Scaling}
By the same token, scaling along the principal axes is performed by setting the diagonal matrix elements:
\begin{equation}
	\left( \begin{array}{c} s_x \cdot x \\ s_y \cdot y \\ s_z \cdot z \\ 1 \end{array} \right) 
	\ =\  
	\left( \begin{array}{cccc} 
		s_x & 0 & 0 & 0 \\
		0 & s_y & 0 & 0 \\
		0 & 0 & s_z & 0 \\
		0 & 0 & 0 & 1
	\end{array} \right) \cdot
	\left( \begin{array}{c} x \\ y \\ z \\ 1 \end{array} \right).
\end{equation}
% -----------------------------------------------------------------------------


% -----------------------------------------------------------------------------
% rotation
% -----------------------------------------------------------------------------
\subsection{Rotation}
The set of rotations in three-dimensional space forms an algebraic group, the special orthogonal group $\mathrm{SO\left(3\right)}$,
which comprises all orthogonal matrices with determinant 1.
There are two popular ways to describe rotations $R \in \mathrm{SO\left(3\right)}$ given the rotation axis and angle, 
namely the Rodrigues formalism and quaternions. 
% As they are both ubiquitous in computer graphics, we describe each of them briefly in the following paragraphs.
For clarity, we only write out the left-upper 3x3 part of the homogeneous 4x4 matrices.


\subsubsection{Rodrigues formalism}
For the derivation in this section we follow Refs. \cite[p. 718, p. 816]{Arens2015} and \cite{wiki_rodrigues}.
The matrix $R$ describing the rotation about a normalised vector $\left|v\right>$ under an angle $\alpha$ can be decomposed into
three projections onto the rotated coordinate system \cite[p. 718, p. 816]{Arens2015}:
\begin{equation}
	\boxed{R \ = \ P_{||} + P_{\perp} \cos \alpha + P_{\times} \sin \alpha.}
	\label{eq:rodrigues}
\end{equation}
Here, $P_{||}$ is the projector onto the axis itself, which remains invariant under a rotation and is written as \cite[p. 814]{Arens2015}:
\begin{equation}
	P_{||} \ =\ \left|v\right> \left<v\right| \ =\ 
		\left( \begin{array}{ccc} 
			v_1^2   &    v_1 v_2 &       v_1 v_3 \\
			v_2 v_1 &      v_2^2 &       v_2 v_3 \\
			v_3 v_1 &    v_3 v_2 &         v_3^2
		\end{array} \right).
\end{equation}
To see that this is the case, one can apply a the projector to a test vector $\left| x \right>$ resulting in $\left|v\right> \left<v | x \right>$,
which is the projection of $\left| x \right>$ onto $\left| v \right>$ in the direction of $\left| v \right>$ \cite[p. 814]{Arens2015}.

The second axis for rotation is found by applying $P_{\perp}$, the orthogonal projector onto the plane, 
whose normal is given by $\left|v\right>$, and which reads \cite[p. 814]{Arens2015}
\begin{equation}
	P_{\perp} \ =\ 1 - \left|v\right> \left<v\right| \ =\ 
		\left( \begin{array}{ccc} 
			1 - v_1^2    &      - v_1 v_2 &         - v_1 v_3 \\
			   - v_2 v_1 &      1 - v_2^2 &         - v_2 v_3 \\
			   - v_3 v_1 &      - v_3 v_2 &         1 - v_3^2
		\end{array} \right).
\end{equation}
Here, $1$ names the unit matrix, and the equation is derived from completeness relation of the vector space under
a basis $\left| v_i \right>$ \cite[p. 814]{Arens2015}:
\begin{equation}
	1 \ =\  \sum_i \left| v_i \right> \left< v_i \right|.
\end{equation}

Finally, the third axis is found by applying $P_{\times}$, the skew-symmetric matrix for $\left|v\right>$.
This is the matrix which -- when applied to a vector $\left|x\right>$ -- gives the cross product of $\left|v\right>$ and $\left|x\right>$, 
and it reads \cite{wiki_skewsymm}:
\begin{equation}
	P_{\times} \ =\ 
		\left( \begin{array}{ccc} 
			0     & -v_3 &  v_2 \\
			v_3   & 0    & -v_1 \\
			-v_2  & v_1  & 0
		\end{array} \right).
\end{equation}

Explicitly writing Eq. \ref{eq:rodrigues} thus yields the full Rodrigues formula \cite[p. 718, p. 816]{Arens2015}:
\begin{equation}
	R \ = \ 
		\left( \begin{array}{ccc} 
			v_1^2   &    v_1 v_2 &       v_1 v_3 \\
			v_2 v_1 &      v_2^2 &       v_2 v_3 \\
			v_3 v_1 &    v_3 v_2 &         v_3^2
		\end{array} \right)
	+ 	\left( \begin{array}{ccc} 
			1 - v_1^2    &      - v_1 v_2 &         - v_1 v_3 \\
			   - v_2 v_1 &      1 - v_2^2 &         - v_2 v_3 \\
			   - v_3 v_1 &      - v_3 v_2 &         1 - v_3^2
		\end{array} \right)
		\cos \alpha 
	 + 
		\left( \begin{array}{ccc} 
			0     & -v_3 &  v_2 \\
			v_3   & 0    & -v_1 \\
			-v_2  & v_1  & 0
		\end{array} \right)
		\sin \alpha.
	\label{eq:rodrigues_expl}
\end{equation}

Using the canonical coordinate basis vectors $\left| x \right> = \left( 1\,0\,0 \right)^t$, $\left| y \right> = \left( 0\,1\,0 \right)^t$,
and $\left| z \right> = \left( 0\,0\,1 \right)^t$, respectively, we reproduce the well-known simple rotation matrices as 
special cases \cite{TODO}:
\begin{equation}
	R_x \ =\ 
		\left( \begin{array}{ccc} 
			1 &            0 &            0  \\
			0 &  \cos \alpha & -\sin \alpha  \\
			0 & \sin \alpha  &  \cos \alpha
		\end{array} \right),\,
	R_y \ =\ 
		\left( \begin{array}{ccc} 
			  \cos \alpha &         0 &  \sin \alpha \\
			           0  &         1 &            0 \\
			-\sin \alpha  &         0 &  \cos \alpha
		\end{array} \right),\,
	R_z \ =\ 
		\left( \begin{array}{ccc} 
			 \cos \alpha & -\sin \alpha &             0  \\
			\sin \alpha  &  \cos \alpha &             0  \\
			           0 &            0 &             1
		\end{array} \right).
\end{equation}


\subsubsection{Quaternions}
Quaternions are hyper-complex numbers of the form $w + x \cdot i + y \cdot j + z \cdot k$, possessing one real 
component, $w$, and three imaginary components, $x$, $y$, and $z$. 
Usually, quaternions are written as tuples $\left( w,\,x,\,y,\,z \right) = \left( w,\,\underline{v} \right) \in \mathbb{H}$,
where the three imaginary components are treated as a vector component.
Algebraically, quaternions form the division ring $\mathbb{H}$, named after William Rowan Hamilton, which follows from the 
basic properties of the three imaginary units, $i$, $j$, and $k$:
\begin{equation}
	i^2 \ =\ j^2 \ =\ k^2 \ =\ ijk \ =\ -1.
	\label{eq:quat_basic}
\end{equation}
A very good in-depth treatise of quaternion algebra and analysis can be found in the book by Kuipers \cite{Kuipers2002},
which we follow in this section.
Here we only present some important results, please refer to \cite{Kuipers2002} for the derivations.

\paragraph{Quaternion multiplication}
The product of two quaternions $\left( w_1,\,\underline{v_1} \right),\ \left( w_2,\,\underline{v_2} \right) \in \mathbb{H}$ 
derives from the basic algebraic property (Eq. \ref{eq:quat_basic}) and is \cite[pp. 106-110]{Kuipers2002}:
\begin{equation}
	\left( w_1, \,\underline{v_1} \right) \cdot \left( w_2, \;\underline{v_2} \right) \ \equiv \ 
	\left( w_1 w_2 - \underline{v_1} \cdot \underline{v_2}, \;\underline{v_1} \times \underline{v_2} + w_1 \underline{v_2} + w_2 \underline{v_1}\right).
\end{equation}
Multiplying a quaternion $q = \left( r,\, \underline{s} \right) \in \mathbb{H}$ with a vector 
$\underline{v} \in \mathbb{R}^3$  reduces to two quaternion multiplications and is done by \cite[p. 127]{Kuipers2002}:
\begin{equation}
	q \cdot \underline{v} \ =\ 
	q \cdot \left(0,\ \underline{v} \right) \cdot q^{*} \ =\ 
	\left( r,\, \underline{s} \right) \cdot \left(0,\ \underline{v} \right) \cdot \left( r,\, -\underline{s} \right).
	\label{eq:mult_quat_vec}
\end{equation}
where $q^{*} = \left( r,\, -\underline{s} \right)$ is the complex conjugate quaternion \cite[pp. 110-111]{Kuipers2002}.

\paragraph{SO(3)}
The special orthogonal group $\mathrm{SO\left(3\right)}$, which comprises rotations in three-dimensional space by an angle
$\alpha$ around a normalised vector $\underline{v}$, can be directly written in quaternion form in an analogy to 
Euler's formula for complex numbers \cite{wiki_quatrot}:
\begin{equation}
	\boxed{
	q_{\mathrm{rot}} \ =\ \left(\cos\left(\alpha/2 \right),\; \sin\left(\alpha/2 \right) \cdot \underline{v} \right).
	}
	\label{eq:quatrot}
\end{equation}
This is the quaternion equivalent of Eq. \ref{eq:rodrigues}. One can readily prove that Eqs. \ref{eq:rodrigues} and \ref{eq:quatrot} are equal by applying both formulas to a test vector (using the multiplication rule of Eq.
\ref{eq:mult_quat_vec} in the  latter case), simplifying occurring expressions using trigonometric 
identities \cite{wiki_trig} and triple vector products of the form 
$\left(\underline{a} \times \underline{b}\right) \times \underline{c} = 
	\left( \underline{c}\cdot \underline{a} \right) \underline{b} - 
	\left( \underline{c}\cdot \underline{b} \right) \underline{a}$ \cite{wiki_tripleprod},
and verifying that the results are equal in both cases.
% -----------------------------------------------------------------------------


% -----------------------------------------------------------------------------
% projections
% -----------------------------------------------------------------------------
\section{3-d to 2-d projections}
\label{sec:gl_projs}

\subsubsection{Parallel projection}
The standard orthogonal projection matrix is given as \cite{web_gl_ortho}:
\begin{equation}
	P_{\mathrm{ortho}} \ =\
		\left( \begin{array}{cccc}
			\frac{2}{r-l} &                             0 &                             0 &  \frac{l+r}{l-r}                  \\
			            0 &  \sigma_y \cdot \frac{2}{t-b} &                             0 &  \sigma_y \cdot \frac{b+t}{b-t}   \\
			            0 &                             0 &  \sigma_z \cdot \frac{s}{n-f} &  \sigma_z \cdot \frac{n+f_0}{n-f} \\
			            0 &                             0 &                             0 &  1
		\end{array} \right),
\end{equation}
where $l$, $r$, $b$, $t$, $n$ and $f$ are the distances of the left, right, bottom, top, near and far planes, respectively.
The $\sigma_{y,\, z}$ are sign factors depending on the definition of the coordinate system and its handedness,
$s$ and $f_0$ are scaling factors. The values for these constants are given in table \ref{tab:gl_constants}.



\subsubsection{Perspective projection}
The standard perspective projection matrix is given as \cite{web_gl_perspective}:
\begin{equation}
	P_{\mathrm{ortho}} \ =\
		\left( \begin{array}{cccc}
			\frac{\rho}{\tan\left(\phi/2 \right)} &                                                  0 &                                 0 &  0                 \\
			                                    0 &  \sigma_y \cdot \frac{1}{\tan\left(\phi/2 \right)} &                                 0 &  0                 \\
			                                    0 &                                                  0 &  \sigma_z \cdot \frac{n_0+f}{n-f} &  \frac{s n f}{n-f} \\
			                                    0 &                                                  0 &                         -\sigma_z &  0
		\end{array} \right),
\end{equation}
where the variables have the same meaning as in the orthogonal projection case.
Additionally, $\phi$ names the field of view angle and $\rho$ is the screen ratio (e.g. 9/16 or 3/4).
$n_0$ is a scaling factor. Typical values are given in table \ref{tab:gl_constants}.


\begin{table}[htb]
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		    Constant &  \textit{OpenGL} &   \textit{Vulkan} \tabularnewline
		\hline
		  $\sigma_y$ &              $1$ &              $-1$ \tabularnewline
		  $\sigma_z$ &              $1$ &               $1$ \tabularnewline
		       $n_0$ &              $n$ &               $0$ \tabularnewline
		       $f_0$ &              $f$ &               $0$ \tabularnewline
		         $s$ &              $2$ &               $1$ \tabularnewline
		\hline
	\end{tabular}
	\caption[Projection matrix constants]{
		Constant values for the perspective and orthogonal projection matrices used in the
		\textit{OpenGL} \cite{web_OpenGL} and \textit{Vulkan} \cite{web_Vulkan} graphics libraries.}
	\label{tab:gl_constants}
\end{table}
% -----------------------------------------------------------------------------



% -----------------------------------------------------------------------------
% window/viewport trafo
% -----------------------------------------------------------------------------
\section{Window transformation}
\label{sec:gl_viewport}
Scaling the projected screen coordinates into the graphics window with width $w$, height $h$, near
$z$ value $n$ and far $z$ value $f$ is done by the following matrix \cite{web_gl_viewport}:
\begin{equation}
	W \ =\ 
	\left( \begin{array}{cccc} 
		w/2 &   0 &                  0 &                w/2 \\
		  0 & h/2 &                  0 &                h/2 \\
		  0 &   0 & \left(f-n\right)/2 & \left(f+n\right)/2 \\
		  0 &   0 &                  0 &                  1
	\end{array} \right) \cdot
\end{equation}
% -----------------------------------------------------------------------------



% -----------------------------------------------------------------------------
% rendering / shaders
% -----------------------------------------------------------------------------
\section{Rendering}
\label{sec:gl_shaders}
Rendering in \textit{OpenGL} is performed using shaders -- small programs that are executed on 
the GPU are are written in the \textit{OpenGL Shading Language} (\textit{GLSL}) \cite{wiki_glsl} -- 
where a minimum rendering pipeline consists of at least a so-called vertex and a fragment shader. 
Vertex shaders are called for each vertex of a given geometry composed of triangles.
They are responsible for the transformations of the vertices from object into screen space as described above.
Fragment shaders are used for the rasterisation of triangles, i.e. drawing all its pixels on the screen. 
They are, for instance, used to apply colours and textures to polygons.

Constant values, such as the transformation and projection matrices mentioned above, can be propagated from the 
user (CPU) program to the shaders. To that end, \textit{OpenGL} provides API functions that allow the user 
program to write to shader variables that have been declared with the keyword \lstinline[language=C]|uniform|.

The actual geometric information such as vertex positions, vertex normals, but also colours, are declared as
input attributes to the vertex shader using the keyword \lstinline[language=C]|in|.
Attributes can be set from the user program by binding a vertex array to them. 
Such an array has the exact configuration that is given by the vertex shader's order of \lstinline[language=C]|in| variables.
The elements of the vertex array are each transformed by the vertex shader program, which stores the resulting 
transformed and projected screen space position in a reserved variable named \lstinline[language=C]|gl_Position|.
Further results can be output from the shader by declaring \lstinline[language=C]|out| variables.
These variables are connected to the inputs of the next shader in the rendering pipeline.
% -----------------------------------------------------------------------------
